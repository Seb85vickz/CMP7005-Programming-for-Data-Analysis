# -*- coding: utf-8 -*-
"""app00000.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MykjX9rUTkmsXNlposxE5kbIan5uENki
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import r2_score, mean_squared_error
from xgboost import XGBRegressor

# ==========================================
# 1. PAGE CONFIGURATION
# ==========================================
st.set_page_config(
    page_title="Air Quality AI Dashboard",
    page_icon="pK",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for a modern look
st.markdown("""
<style>
    .main {
        background-color: #f5f5f5;
    }
    .stButton>button {
        color: white;
        background-color: #007BFF;
        border-radius: 10px;
    }
    .metric-card {
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
    }
</style>
""", unsafe_allow_html=True)

# ==========================================
# 2. DATA CACHING & LOADING
# ==========================================
@st.cache_data
def load_data(uploaded_file):
    if uploaded_file is not None:
        df = pd.read_csv(uploaded_file)
    else:
        # FALLBACK: Create dummy data if no file is uploaded yet (for demo purposes)
        dates = pd.date_range(start='2015-01-01', periods=1000)
        data = {
            'City': np.random.choice(['Delhi', 'Ahmedabad', 'Mumbai', 'Bengaluru'], 1000),
            'Date': dates,
            'PM2.5': np.random.uniform(10, 300, 1000),
            'PM10': np.random.uniform(20, 400, 1000),
            'NO2': np.random.uniform(5, 100, 1000),
            'CO': np.random.uniform(0.1, 5, 1000),
            'SO2': np.random.uniform(1, 50, 1000),
            'O3': np.random.uniform(5, 100, 1000),
            'AQI': np.random.uniform(50, 500, 1000)
        }
        df = pd.DataFrame(data)

    # Preprocessing
    df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
    df['Year'] = df['Date'].dt.year
    df['Month'] = df['Date'].dt.month_name()
    return df

# ==========================================
# 3. SIDEBAR NAVIGATION
# ==========================================
st.sidebar.title("Navigation")
st.sidebar.image("https://cdn-icons-png.flaticon.com/512/2964/2964514.png", width=100)
page = st.sidebar.radio("Go to", ["Home", "Interactive EDA", "Model Evaluation", "Live Prediction"])

# Sidebar Data Upload
st.sidebar.divider()
st.sidebar.subheader("Data Configuration")
uploaded_file = st.sidebar.file_uploader("Upload your cleaned CSV", type=["csv"])

# Load Data
df = load_data(uploaded_file)

if uploaded_file is None:
    st.sidebar.warning("Using generated demo data. Upload your CSV for real results!")

# ==========================================
# 4. PAGE: HOME
# ==========================================
if page == "Home":
    st.title("‚òÅÔ∏è Air Quality Index (AQI) Analytics")
    st.markdown("### Powered by Machine Learning & Streamlit")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("""
        **Project Overview:**
        This application analyzes historical air quality data from major Indian cities and uses **XGBoost** to predict PM2.5 levels.

        **Key Features:**
        - üìä **Interactive Charts:** Zoom, pan, and filter data.
        - ü§ñ **AI Prediction:** Real-time pollutant forecasting.
        - üìà **Trend Analysis:** Seasonal and yearly breakdown.
        """)

    with col2:
        st.info(f"**Current Dataset Stats:**\n\n- Rows: {df.shape[0]}\n- Cities: {df['City'].unique().tolist()}\n- Date Range: {df['Date'].dt.date.min()} to {df['Date'].dt.date.max()}")

    st.subheader("Dataset Preview")
    st.dataframe(df.head(), use_container_width=True)

# ==========================================
# 5. PAGE: INTERACTIVE EDA
# ==========================================
elif page == "Interactive EDA":
    st.title("üìä Exploratory Data Analysis")

    # Filters
    col1, col2 = st.columns(2)
    with col1:
        selected_cities = st.multiselect("Select Cities", df['City'].unique(), default=df['City'].unique()[:2])
    with col2:
        pollutant = st.selectbox("Select Pollutant", ['PM2.5', 'PM10', 'NO2', 'CO', 'SO2', 'O3', 'AQI'])

    # Filter Data
    if not selected_cities:
        st.warning("Please select at least one city.")
    else:
        filtered_df = df[df['City'].isin(selected_cities)]

        # 1. Time Series Plot
        st.subheader(f"üìÖ {pollutant} Trends Over Time")
        fig_ts = px.line(filtered_df, x='Date', y=pollutant, color='City',
                         title=f"{pollutant} Levels (Time Series)", template="plotly_white")
        st.plotly_chart(fig_ts, use_container_width=True)

        # 2. Year-wise Comparison
        st.subheader("üìÖ Year-wise Comparison")
        fig_bar = px.box(filtered_df, x='Year', y=pollutant, color='City',
                         title=f"Distribution of {pollutant} by Year")
        st.plotly_chart(fig_bar, use_container_width=True)

        # 3. Correlation Heatmap
        st.subheader("üîó Pollutant Correlation Matrix")

        # Select only numeric cols for correlation
        numeric_df = filtered_df.select_dtypes(include=[np.number])
        if 'Year' in numeric_df.columns: numeric_df = numeric_df.drop(columns=['Year'])

        corr = numeric_df.corr()
        fig_corr = px.imshow(corr, text_auto=True, aspect="auto", color_continuous_scale='RdBu_r',
                             title="Correlation Heatmap")
        st.plotly_chart(fig_corr, use_container_width=True)

# ==========================================
# 6. PAGE: MODEL EVALUATION
# ==========================================
elif page == "Model Evaluation":
    st.title("ü§ñ Model Training & Performance")

    if st.button("Train XGBoost Model"):
        with st.spinner("Training Model... Please wait..."):
            # Data Prep
            target = 'PM2.5'
            features = ['PM10', 'NO2', 'CO', 'SO2', 'O3', 'AQI']
            # Ensure features exist in df
            features = [f for f in features if f in df.columns]

            df_model = df.dropna(subset=[target] + features)

            X = df_model[features]
            y = df_model[target]

            # Split
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=False)

            # Scale
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)

            # Train
            model = XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1)
            model.fit(X_train_scaled, y_train)

            # Predict
            y_pred = model.predict(X_test_scaled)

            # Metrics
            r2 = r2_score(y_test, y_pred)
            rmse = np.sqrt(mean_squared_error(y_test, y_pred))

            # Save to session state
            st.session_state['model'] = model
            st.session_state['scaler'] = scaler
            st.session_state['features'] = features
            st.session_state['r2'] = r2
            st.session_state['rmse'] = rmse
            st.session_state['y_test'] = y_test
            st.session_state['y_pred'] = y_pred

    # Display Results if model is trained
    if 'model' in st.session_state:
        st.success("Model Trained Successfully!")

        col1, col2 = st.columns(2)
        with col1:
            st.metric("R2 Score (Accuracy)", f"{st.session_state['r2']:.4f}", delta="High is Good")
        with col2:
            st.metric("RMSE (Error)", f"{st.session_state['rmse']:.4f}", delta="-Lower is Better", delta_color="inverse")

        # Actual vs Predicted Plot
        st.subheader("Actual vs Predicted PM2.5")
        results_df = pd.DataFrame({'Actual': st.session_state['y_test'], 'Predicted': st.session_state['y_pred']})

        fig_scat = px.scatter(results_df, x='Actual', y='Predicted', opacity=0.5,
                              title="Regression Fit Analysis", template="plotly_dark")
        fig_scat.add_shape(type="line", x0=results_df['Actual'].min(), y0=results_df['Actual'].min(),
                           x1=results_df['Actual'].max(), y1=results_df['Actual'].max(),
                           line=dict(color="Red", width=2, dash="dash"))
        st.plotly_chart(fig_scat, use_container_width=True)
    else:
        st.info("Click the button above to train the model and see performance metrics.")

# ==========================================
# 7. PAGE: LIVE PREDICTION
# ==========================================
elif page == "Live Prediction":
    st.title("‚ö° Live AQI Predictor")
    st.markdown("Adjust the sliders below to simulate pollutant levels and predict **PM2.5**.")

    if 'model' not in st.session_state:
        st.warning("‚ö†Ô∏è Please train the model in the 'Model Evaluation' page first!")
    else:
        # Create input fields dynamically based on features
        inputs = {}
        cols = st.columns(3)
        features = st.session_state['features']

        for i, feature in enumerate(features):
            with cols[i % 3]:
                min_val = float(df[feature].min())
                max_val = float(df[feature].max())
                mean_val = float(df[feature].mean())
                inputs[feature] = st.slider(f"{feature} Level", min_val, max_val, mean_val)

        # Predict Button
        if st.button("Predict PM2.5"):
            # Prepare input array
            input_array = np.array([list(inputs.values())])

            # Scale input
            input_scaled = st.session_state['scaler'].transform(input_array)

            # Predict
            prediction = st.session_state['model'].predict(input_scaled)[0]

            # Display Result
            st.divider()
            col1, col2 = st.columns([1, 2])

            with col1:
                st.metric("Predicted PM2.5", f"{prediction:.2f} ¬µg/m¬≥")

            with col2:
                # AQI Bucket Logic (Simplified)
                if prediction <= 30:
                    status = "Good üü¢"
                    msg = "Air quality is satisfactory."
                elif prediction <= 60:
                    status = "Satisfactory üü°"
                    msg = "Air quality is acceptable."
                elif prediction <= 90:
                    status = "Moderately Polluted üü†"
                    msg = "Breathing discomfort to sensitive people."
                elif prediction <= 120:
                    status = "Poor üî¥"
                    msg = "Breathing discomfort to most people."
                else:
                    status = "Severe üü£"
                    msg = "Respiratory effects even on healthy people."

                st.subheader(f"Status: {status}")
                st.write(msg)